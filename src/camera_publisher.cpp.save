#include <rclcpp/rclcpp.hpp>
#include <image_transport/image_transport.hpp>
#include <opencv2/opencv.hpp>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/msg/image.hpp>
#include <std_msgs/msg/string.hpp> 
#include <px4_msgs/msg/sensor_gps.hpp> // GPS Zamanı burada
#include <algorithm> 
#include <ctime> // Saat hesaplaması için

using namespace std::chrono_literals;

class CameraPublisher : public rclcpp::Node
{
public:
    CameraPublisher()
        : Node("camera_publisher")
    {
        this->declare_parameter("video_device", "/dev/video0");
        this->declare_parameter("frame_width", 640);
        this->declare_parameter("frame_height", 480);
        this->declare_parameter("frame_rate", 30.0);
        this->declare_parameter("frame_id", "camera_link");

        device_path_ = this->get_parameter("video_device").as_string();
        width_ = this->get_parameter("frame_width").as_int();
        height_ = this->get_parameter("frame_height").as_int();
        fps_ = this->get_parameter("frame_rate").as_double();
        frame_id_ = this->get_parameter("frame_id").as_string();

        rclcpp::QoS px4_qos = rclcpp::SensorDataQoS(); 
        rmw_qos_profile_t camera_qos = rmw_qos_profile_sensor_data;

        publisher_ = image_transport::create_publisher(this, "camera/image_raw", camera_qos);

        subscription_ = this->create_subscription<std_msgs::msg::String>(
            "/state", 10, std::bind(&CameraPublisher::state_callback, this, std::placeholders::_1));

        // GPS verisini (Zaman için) tekrar dinlemeye başladık
        gps_sub_ = this->create_subscription<px4_msgs::msg::SensorGps>(
            "/fmu/out/vehicle_gps_position", 
            px4_qos, 
            std::bind(&CameraPublisher::gps_callback, this, std::placeholders::_1));
        
        init_camera();
        
        frame_ = cv::Mat(height_, width_, CV_8UC3);
        gray_frame_ = cv::Mat(height_, width_, CV_8UC1);

        timer_ = this->create_wall_timer(
            std::chrono::duration<double>(1.0 / fps_),
            std::bind(&CameraPublisher::timer_callback, this));

        RCLCPP_INFO(this->get_logger(), "MOD: GPS SAATİ (UTC) Aktif");
    }

private:
    }

    void init_camera()
    {
        if (cap_.isOpened()) cap_.release();
        bool is_number = !device_path_.empty() && std::all_of(device_path_.begin(), device_path_.end(), ::isdigit);
        
        if (is_number) cap_.open(std::stoi(device_path_), cv::CAP_V4L2);
        else cap_.open(device_path_, cv::CAP_V4L2);

        if (cap_.isOpened()) {
            cap_.set(cv::CAP_PROP_FOURCC, cv::VideoWriter::fourcc('M', 'J', 'P', 'G'));
            cap_.set(cv::CAP_PROP_FRAME_WIDTH, width_);
            cap_.set(cv::CAP_PROP_FRAME_HEIGHT, height_);
            cap_.set(cv::CAP_PROP_FPS, fps_);
        }
    }

    void timer_callback()
    {
        if (!cap_.isOpened()) { init_camera(); return; }
        cap_ >> frame_;
        if (frame_.empty()) return;

        std_msgs::msg::Header header;
        header.stamp = this->now();
        header.frame_id = frame_id_;

        // --- GPS SAATİNİ YAZDIRMA ---
        char buffer[100];
        
        if (gps_locked_) {
            // Format: HH:MM:SS.mmm
            // %02d: 2 hane, boşsa 0 koy. %03d: 3 hane milisaniye
            sprintf(buffer, "UTC: %02d:%02d:%02d.%03d", 
                time_struct_.tm_hour, 
                time_struct_.tm_min, 
                time_struct_.tm_sec,
                millis_);
        } else {
            sprintf(buffer, "GPS Time: Waiting...");
        }

        std::string time_text(buffer);

        // Kamikaze Modu Rengi
        cv::Scalar text_color = kamikaze_mode_ ? cv::Scalar(255) : cv::Scalar(0, 255, 0); // Beyaz veya Yeşil
        
        // Ekrana Yaz (Biraz daha büyük fontla)
        cv::putText(frame_, time_text, cv::Point(20, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, text_color, 2);

        sensor_msgs::msg::Image::SharedPtr msg;
        try {
            if (kamikaze_mode_) {
                cv::cvtColor(frame_, gray_frame_, cv::COLOR_BGR2GRAY);
                msg = cv_bridge::CvImage(header, "mono8", gray_frame_).toImageMsg();
            } else {
                msg = cv_bridge::CvImage(header, "bgr8", frame_).toImageMsg();
            }
            publisher_.publish(std::move(msg));
        } catch (cv_bridge::Exception& e) {}
    }

    image_transport::Publisher publisher_;
    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
    rclcpp::Subscription<px4_msgs::msg::SensorGps>::SharedPtr gps_sub_;

    cv::VideoCapture cap_;
    rclcpp::TimerBase::SharedPtr timer_;
    cv::Mat frame_, gray_frame_;
    std::string device_path_;
    int width_, height_;
    double fps_;
    std::string frame_id_;
    bool kamikaze_mode_ = false;

    // Zaman Değişkenleri
    struct tm time_struct_;
    int millis_ = 0;
    bool gps_locked_ = false;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<CameraPublisher>());
    rclcpp::shutdown();
    return 0;
}
